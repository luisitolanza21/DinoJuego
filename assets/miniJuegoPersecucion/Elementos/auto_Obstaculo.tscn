[gd_scene load_steps=3 format=3 uid="uid://c6ehfg3g6ugu3"]

[ext_resource type="Texture2D" uid="uid://c2r1x2uch1i8b" path="res://assets/miniJuegoPersecucion/res/ImagenesAuto/auto 3.png" id="1_7em3x"]

[sub_resource type="GDScript" id="GDScript_cs50k"]
script/source = "extends CharacterBody2D

@export var MAX_SPEED = 500.0           # Velocidad máxima que puede alcanzar el coche
@export var ACCELERATION = 500.0        # Aceleración para alcanzar la velocidad objetivo
@export var DECELERATION = 200.0        # Desaceleración para frenar
@export var CONSTANT_SPEED = 200.0      # Velocidad constante para movimiento constante
@export var SAFE_DISTANCE = 100.0       # Distancia mínima para detectar obstáculos
@export var REACTION_TIME = 0.2         # Tiempo de reacción para frenar ante obstáculos
@export var BRAKE_FORCE = 1.5           # Multiplicador para la fuerza de frenado

var velocity_target = Vector2.ZERO      # Velocidad objetivo para el movimiento del coche
var is_braking = false                  # Indica si el coche está frenando
var next_direction = 0                  # Dirección horizontal siguiente (-1: izquierda, 1: derecha)
var next_vertical_direction = 0         # Dirección vertical siguiente (-1: abajo, 1: arriba)

# Referencias a los RayCast2D
var raycast_front: RayCast2D
var raycast_top: RayCast2D
var raycast_bottom: RayCast2D

func _ready():
	# Obtener las referencias a los RayCasts en el nodo
	raycast_front = $RayCast2DFrontal
	raycast_top = $lateralSuperior
	raycast_bottom = $lateralInferior

	# Activar los RayCasts para que empiecen a detectar colisiones
	raycast_front.cast_to = Vector2(SAFE_DISTANCE, 0)   # Adelante
	raycast_top.cast_to = Vector2(0, -SAFE_DISTANCE)    # Arriba
	raycast_bottom.cast_to = Vector2(0, SAFE_DISTANCE)  # Abajo

	raycast_front.is_active = true
	raycast_top.is_active = true
	raycast_bottom.is_active = true

func _physics_process(delta):
	# Control del coche con las teclas (para depuración; se puede remover para control automático)
	var input_direction = 1
	var input_vertical = 0;

	# Aquí se puede aplicar la lógica de velocidad constante o manual
	if _should_use_constant_speed():  # Lógica para determinar si se debe usar velocidad constante
		velocity_target.x = CONSTANT_SPEED  # Establece la velocidad constante
		next_direction = 0  # Resetea la dirección para evitar cambio de velocidad
	else:
		next_direction = input_direction  # Usa la entrada del jugador para la dirección

	# Decide la dirección vertical del movimiento (puede ser parte de la IA o del jugador)
	next_vertical_direction = input_vertical  # Usa la entrada del jugador para dirección vertical

	# Verifica si hay obstáculos y ajusta el movimiento si es necesario
	_handle_obstacles(delta)

	# Actualiza la velocidad objetivo considerando velocidad constante y frenado
	velocity_target.x = _clamp_velocity(delta, velocity_target.x, next_direction * MAX_SPEED, is_braking)
	velocity_target.y = _clamp_velocity(delta, velocity_target.y, next_vertical_direction * MAX_SPEED, is_braking)

	# Aplica la velocidad usando `move_and_slide` para manejar colisiones
	velocity.x = move_toward(velocity.x, velocity_target.x, ACCELERATION * delta)
	velocity.y = move_toward(velocity.y, velocity_target.y, ACCELERATION * delta)
	move_and_slide()

func _handle_obstacles(delta):
	# Detecta colisiones con obstáculos en la dirección frontal
	if raycast_front.is_colliding() and raycast_front.get_collider().is_in_group(\"obstacle\"):
		print(\"Obstacle detected in front!\")
		# Si hay un obstáculo, inicia el frenado
		is_braking = true
		velocity_target.x = move_toward(velocity_target.x, 0, DECELERATION * delta * BRAKE_FORCE)

	elif raycast_top.is_colliding() and raycast_top.get_collider().is_in_group(\"obstacle\"):
		print(\"Obstacle detected on top!\")
		# Lógica para manejar obstáculos en la parte superior
		# Por ejemplo, podrías cambiar de carril o ralentizar

	elif raycast_bottom.is_colliding() and raycast_bottom.get_collider().is_in_group(\"obstacle\"):
		print(\"Obstacle detected below!\")
		# Lógica para manejar obstáculos en la parte inferior
		# Podrías ajustar la dirección vertical o frenar

	else:
		# Si no hay obstáculos, reanuda el movimiento normal
		is_braking = next_direction != 0  # Frena si cambia de dirección para evitar sobrepasar
		# También se puede añadir lógica para disminuir gradualmente la fuerza de frenado

func _clamp_velocity(delta, current_velocity, target_velocity, is_braking):
	# Limita la velocidad en función del objetivo y el estado de frenado
	if is_braking:
		return move_toward(current_velocity, target_velocity, DECELERATION * delta)
	else:
		return clamp(current_velocity, -MAX_SPEED, MAX_SPEED)

func _should_use_constant_speed() -> bool:
	# Lógica para determinar si se debe usar velocidad constante
	# Ejemplo: velocidad constante si no se presionan las teclas de dirección
	return next_direction == 0 and next_vertical_direction == 0
"

[node name="autoMovil1" type="CharacterBody2D"]
position = Vector2(113, 90)
script = SubResource("GDScript_cs50k")

[node name="Auto3" type="Sprite2D" parent="."]
position = Vector2(-113, -89)
scale = Vector2(0.413556, 0.510235)
texture = ExtResource("1_7em3x")

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="."]
polygon = PackedVector2Array(-214, -128, -213, -47, -199, -37, -191, -37, -186, -23, -177, -19, -165, -21, -158, -36, -66, -36, -56, -22, -47, -20, -38, -27, -35, -37, -12, -36, -13, -108, -15, -109, -16, -127, -69, -127, -85, -157, -167, -158, -187, -127)

[node name="lateralSuperior" type="RayCast2D" parent="."]
position = Vector2(-113, -130)
target_position = Vector2(-1, -59)

[node name="lateralInferior" type="RayCast2D" parent="."]
position = Vector2(-114, -95)
target_position = Vector2(1, 89)

[node name="RayCast2DFrontal" type="RayCast2D" parent="."]
position = Vector2(-25, -87)
target_position = Vector2(95, 0)
